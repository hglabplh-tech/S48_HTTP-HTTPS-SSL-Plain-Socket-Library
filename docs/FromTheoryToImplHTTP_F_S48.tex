\documentclass[10pt,a4paper,english]{article}
\usepackage{babel}
\usepackage{ae}
\usepackage{aeguill}
\usepackage{shortvrb}
\usepackage[latin1]{inputenc}
\usepackage{tabularx}
\usepackage{longtable}
\setlength{\extrarowheight}{2pt}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{ifthen}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=blue]{hyperref}
\usepackage[DIV12]{typearea}
%% generator Docutils: http://docutils.sourceforge.net/
\newlength{\admonitionwidth}
\setlength{\admonitionwidth}{0.9\textwidth}
\newlength{\docinfowidth}
\setlength{\docinfowidth}{0.9\textwidth}
\newlength{\locallinewidth}
\newcommand{\optionlistlabel}[1]{\bf #1 \hfill}
\newenvironment{optionlist}[1]
{\begin{list}{}
  {\setlength{\labelwidth}{#1}
   \setlength{\rightmargin}{1cm}
   \setlength{\leftmargin}{\rightmargin}
   \addtolength{\leftmargin}{\labelwidth}
   \addtolength{\leftmargin}{\labelsep}
   \renewcommand{\makelabel}{\optionlistlabel}}
}{\end{list}}
\newlength{\lineblockindentation}
\setlength{\lineblockindentation}{2.5em}
\newenvironment{lineblock}[1]
{\begin{list}{}
  {\setlength{\partopsep}{\parskip}
   \addtolength{\partopsep}{\baselineskip}
   \topsep0pt\itemsep0.15\baselineskip\parsep0pt
   \leftmargin#1}
 \raggedright}
{\end{list}}
% begin: floats for footnotes tweaking.
\setlength{\floatsep}{0.5em}
\setlength{\textfloatsep}{\fill}
\addtolength{\textfloatsep}{3em}
%__________________________________________________________________________________
\newcommand{\code}[1]{{\tt{#1}}}
\renewcommand{\textfraction}{0.5}
\renewcommand{\topfraction}{0.5}
\renewcommand{\bottomfraction}{0.5}
%__________________________________________________________________________________
\setcounter{totalnumber}{50}
\setcounter{topnumber}{50}
\setcounter{bottomnumber}{50}
% end floats for footnotes
% some commands, that could be overwritten in the style file.
\newcommand{\rubric}[1]{\subsection*{~\hfill {\it #1} \hfill ~}}
\newcommand{\abbrhighcol}[1]{\textbf{\textit{#1}}}
\newcommand{\titlereference}[1]{\textsl{#1}}
% end of "some commands"
\title{An implementation of HTTP /HTTPS and SSL for Scheme 48 }
\author{Harald Glab-Plhak {\textless}\href{mailto:hglabplhak@icloud.com}{hglabplhak@icloud.com}{\textgreater}}
\date{\today{}}
%______________________________________________________________________________________
\hypersetup{
pdftitle={An implementation of HTTP /HTTPS and SSL for Scheme 48 },
pdfauthor={Harald Glab-Plhak (staatl.gepr. Inf) {\textless}hglabplhak@icloud.com{\textgreater}}%;Mike Sperber (CEO Active Group Tübingen) {\textless}michael.sperber@active-group.de{\textgreater}}
}

%______________________________________________________________________________________
\begin{document}

%______________________________________________________________________________________

%\textbf{Author}: 
%Mike Sperber. (CEO Active Group Tuebingen) {\textless}\href{mailto:michael.sperber@active-group.de}{michael.sperber@active-group.de}{\textgreater} \

%______________________________________________________________________________________

\maketitle
\tableofcontents

%______________________________________________________________________________________
\begin{multicols}{2}
\section{Abstract}

\begin{flushleft}
What we like to do is to support \abbrhighcol{SSL / HTTP  / HTTPS} in Scheme 48. The interface for that will be implemented nearly implemented as Domain Specific Language for Networking. I will use  \abbrhighcol{LibreSSL} as external library to avoid errors and bugs in the implementation by doing that on my own with much less time than the developers and designers this components have due to much more manpower.  
The goal is to implement the \abbrhighcol{HTTP /1.1} and \abbrhighcol{HTTP/2} and \abbrhighcol{HTTP/3} as well. To get something  like a pseudo standard,  the interface is inspired by the \abbrhighcol{HTTP-EASY} library written in  \abbrhighcol{Racket Language} and is a free style. port of it (we use the codebase and transfer it to real scheme and make it fit to S48)
\href{https://pkgs.racket-lang.org/package/http-easy-lib}{HTTP-EASY (Lib Site)}  which is implemented in racket which is also inspired by scheme and which also has an \abbrhighcol{R6RS} Scheme standard implemented. 
The implementation and interface is committed to the requirements defined by the following  \abbrhighcol{RFC Documents:}
\end{flushleft}

\begin{flushleft}
\hspace*{1em}-- \href{https://datatracker.ietf.org/doc/html/rfc5246}{RFC-5246 (TLS V 1.2)}\\The Transport Layer Security (TLS) Protocol Version 1.2 Authors:   T. Dierks
Independent,  E. Rescorla RTFM, Inc.\\
\end{flushleft}
\begin{flushleft}
\hspace*{1em}-- \href{https://datatracker.ietf.org/doc/html/rfc8446}{RFC-8446 (TLS V 1.3)}\\The Transport Layer Security (TLS) Protocol Version 1.3 Author(s): E. Rescorla Mozilla\\
\end{flushleft}
\begin{flushleft}
\hspace*{1em}-- \href{https://datatracker.ietf.org/doc/html/rfc6101}{RFC-6101 (SSL V 3.0)}\\The Secure Socket Layer  (SSL) Protocol Version 3.0 Authors: A. Freier, P. Karlton Netscape Communications, P. Kocher Independent Consultant\\
\end{flushleft}
\begin{flushleft}
\hspace*{1em}-- \href{https://datatracker.ietf.org/doc/html/rfc3986}{RFC-3986 (URI)}\\The Uniform Resource Identifier (URI) Authors: T. Berners-Lee W3C/MIT, R. Fielding Day. Software, L. Masinter Adobe Systems\\
\end{flushleft}
\begin{flushleft}
\hspace*{1em}-- \href{https://www.rfc-editor.org/rfc/rfc9112.pdf}{RFC-9112 (HTTP/1.1)}\\The specification of the Hyper Text Transfer Protocol / 1.1 ( Authors: R. Fielding, Ed. , M. Nottingham, Ed.,  J. Reschke, Ed. ) \\
\hspace*{1em}-- \href{https://www.rfc-editor.org/rfc/rfc9110.pdf}{RFC-9110 (HTTP Semantics)} \\The semantics specification of the Hyper Text Transfer Protocol (Authors: R. Fielding, Ed., M. Nottingham, Ed., J. Reschke, Ed.)\\
\hspace*{1em}-- \href{https://www.rfc-editor.org/rfc/rfc9113.pdf}{RFC-9113 (HTTP/2)} \\The specification of the Hyper Text Transfer Protocol / 2 ( Authors:             M. Thomson, Ed. , C. Benfield, Ed. )\\
\hspace*{1em}-- \href{https://www.rfc-editor.org/rfc/pdfrfc/rfc7541.txt.pdf}{RFC-7541 (HPAC)} \\HPACK: Field Compression for HTTP/2 Authors:  R. Peon Google Inc., H. Ruellan Canon CRF\\
\hspace*{1em}-- \href{https://www.rfc-editor.org/rfc/rfc9114.pdf}{RFC-9114 (HTTP/3)} \\The specification of the Hyper Text Transfer Protocol / 3( Authors: M. Bishop, Ed. ) \\
\hspace*{1em}-- \href{https://www.rfc-editor.org/rfc/rfc9204.pdf}{RFC-9204 (QPAC)} \\QPACK: Field Compression for HTTP/3 Authors: C. Krasic, M. Bishop Akamai Technologies,
A. Frindell, Ed.Facebook
\end{flushleft}
\begin{flushleft}
In addition to the client library a full  functional toolkit will be implemented for developing application containers with \abbrhighcol {RESTful}\footnote{\abbrhighcol {REST Requests:}The \abbrhighcol {R}epres\abbrhighcol  {E}ntational abbrhighcol{S}tate abbrhighcol{T}ransfer API is an architectural style and the RESTful services follows this specification to design a special form of HTTP requests.} interfaces (e.g. using \abbrhighcol {YAML} definitions) or at last my be application containers and something like \abbrhighcol {OCSP}\footnote{ \abbrhighcol {OCSP}: The \abbrhighcol  {O}pen \abbrhighcol {C}ertificate \abbrhighcol  {S}ervice \abbrhighcol  {P}rotocol is used to implement servers being requested using OCSP Requests and defined OCSP  Responses for checking the correctness and the validity of a certificate.} Services.
This will be really enough for the first step.
\end{flushleft}

\section{Introduction}

\begin{flushleft}
Scheme 48 is a SCHEME interpreter actually following the R5RS standard but the R6RS is nearly ready for delivery. In this implementation up to now there is a net component implementing socket communication.
The first step to reach our goal will be to introduce a SSL capable implementation using the current implementation for port and channel handling to get an appropriate layer definition for  implementing the things for HTTP / HTTPS.
\end{flushleft}
\begin{flushleft}
Short explanation of the Plain Socket / SSL Layer:
For the SSL Layer we built up a little syntax with define-syntax,  which is a define for a new generic usable function definition which contains the protocol definition, the CTX the Certificate and the connection parameters in a record after that this command executes a handshake and  open connection in a way that we  get a port number which can be used either by LibreSSL or by the native C socket API to do HTTP / HTTPS.
Short explanation of the HTTP / HTTPS Layer:
The HTTPS layer  is defined on top of the SSL Layer by the  next \code{define-syntax}.
\end{flushleft}

\subsection{The Sockets implementations }
\begin{flushleft}
First of all we have to design our interface and the syntax and attributes and functional syntactic layout of our tiny DSL. After that it is necessary to build the low level functionality in C so that we can then build our things in scheme. I prefer this way because it is good to see an early success so that the work is not too long before knowing that the concept works. The first part that we develop of course. also as a base for the DSL is a. procedural interface (function calls).
\end{flushleft}
\subsection{Issues for the project}
\begin{flushleft}
Here are some issues  which are important for our task:
 \begin{itemize}
 \item{How read / write is planned}
    \begin{itemize}
        \item{Using the new. Port / Channeel I/O written for R6RS}
        \item{Make it stable for multi-threading via atomically}        
    \end{itemize}
\item{We use some kind of pseudo code to describe the logic here}
   \begin{itemize}
        \item{Using the My Lisp dialect / McCarthy Lisp dialect and formula}
    \end{itemize}
\item{Additional things which we will implement}
    \begin{itemize}
       \item{Implement URL encoding}
       \item{Basic and Certificate AUTH Headers} 
       \item{Implement base for RESTful services including yaml like definition and JSON support}
       \item{Implement MULTIPart attachemenzs with MIME spec.}
   \end{itemize}
\end{itemize}
\end{flushleft}


\subsection{The procedural interface}
\begin{flushleft}
The procedural interface is the interface where several functions are defined for each layer. This interface can be used in a very flexible way. This part is the positive thing about this part of implementation. The negative effect of this part of interface is that the function have to be used in the right way and order. In cause of that we define also a DSL which ensures the usage of the functions in the right way. This part will be described. later. 
For getting a clear architecture the implementations are divided in a low-level interface on which the high level interface (The recommended interface) is built as layer with more simple. and straight arguments not needing too much technical details for better under5standing by the people using the library. 
\end{flushleft}


\subsection{Procedural Interface for Sockets}
\begin{flushleft}
The interface for defining Sockets is build by using the C-Socket API and for the Secure Socket Layer and Transport Security Layer LibreSSL is used.
Th functions we need are called in a Scheme48 FFI Module. The FFI is the Foreign Function Interface. With this interface the functions can be called and S48 values can be returned which we use after defining this layer in the pure scheme part.  
\end{flushleft}

\subsection{Procedural Interface for HTTP/ HTTPS}
\begin{flushleft}
In this part of the procedural interface the HTTP / HTTPS protocols are implemented V1.1 the older nearly outdated format although it is widely used up to now.The V 2.0 with HPAC\footnote{\abbrhighcol{HPAC: } Header Compression for HTTP/2} and V 3.0 with QPAC \footnote{\abbrhighcol{QPAC: } Header Compression for HTTP/3}.  
\end{flushleft}


\subsection{The DSL definition as interface}
\begin{flushleft}
The DSL\footnote{\abbrhighcol{DSL: } A \abbrhighcol {D}omain \abbrhighcol{S}pecific \abbrhighcol{L}anguage is a language normally built up in the host language. A DSL is designed for special tasks and areas e.g.: Windowing.} for the SSL Layer itself will be designed by using the define-syntax and the other hygienic macro functionality.
\end{flushleft}
A Domain specific language has to be defined in a way that the Function / Keywords can be used inside the definition of the syntax for the DSL

\subsection{The SSL syntactic layer}
\begin{flushleft}
 At first we need a syntax to declare a Socket\abbrhighcol  {Plain/ SSL}. Here we have to think about connection parameters and about parameters and attributes for \abbrhighcol  {SSL / TLS} (e.g. \abbrhighcol  {CTX} and certificate keys and a specific Algorithm for transport. 
The\abbrhighcol  {CTX} will be a structure/ record-type as well as the definition of the base connection parameters. 
\end{flushleft}

\subsection{The HTTP / HTTPS  syntactic layer}
\begin{flushleft}
In this layer a grammar is defined to have a save way to create \abbrhighcol{ HTTP (GET, PUT, POST, DELETE,HEAD....)} Requests and to define the request data in the same step. With the created 'object' a send can be done. The same is done for the server side receive the other way round. There is also a grammar defined for sending the HTTP / HTTPS request to the server. and to handle / give back the response. 
\end{flushleft}


%_______________________________________________________________-
% Section three
%_______________________________________________________________-
\section{Procedural interface definitions}
\begin{flushleft}
First we design and implement the procedural interface. In this interface we define functions for the different tasks. The parameters and the returns are designed in a way that  the functions are doing a create of the request, a connection establishment and the send .... for each task there  are  one or more functions. Of course the functions differ if the use either a secure or a non secure connection and transmission. For using that interface a deeper technical know how as in the syntactic layer about all these things and the possibilities is   neccessary.
And now finally let's dive into it more detailed.
\end{flushleft}
\subsection{The SSL procedural interface in C / Scheme}
\begin{flushleft}
\end{flushleft}
\subsection{The HTTP/HTTPS Common functionality}
\begin{flushleft}
\end{flushleft}
\subsection{The HTTP/HTTPS procedural interface in  Scheme}
\begin{flushleft}
\end{flushleft}
\subsection{The transport layer}
\begin{flushleft}
\end{flushleft}
\subsection{The HTTP Method definition and the resource definition}
\begin{flushleft}
\end{flushleft}
\subsection{The QUIC protocol implementation}
\begin{flushleft}
\end{flushleft}
\subsection{The header compression for HTTP/2 and HTTP/3 HPAC / QPAC}
\begin{flushleft}
\end{flushleft}
\subsection{Multipart attachements}
\begin{flushleft}
\end{flushleft}
\subsection{RESTful service layer over HTTP }
\begin{flushleft}
\end{flushleft}

%__________________________________________________________________________________________
\section{APPENDIX A: Terminology Explained in short}
\subsection{The HTTP 1.1 / 2 / 3 Protocol}   
\begin{flushleft}
The HTTP\footnote{\abbrhighcol{HTTP:}  The \abbrhighcol{H}yper \abbrhighcol{T}ext \abbrhighcol {T}ransport \abbrhighcol {P}rotocol used for transport  e.g. \abbrhighcol{HTML} or designing  \abbrhighcol{REST Requests} . The protocol is implemented by all Web Browsers and is used all over the internet to transport / requesting and servicing data in a structured form with defined requests like \abbrhighcol{GET, PUT, DELETE, HEAD ...}. All of these requests have a defined response format.} was developed for transport of data over TCP/IP in a well defined structured way  
The HTTP 1.1 protocol was and is widely used for a long time.
After this the HTTP 2.0 protocol was developed containing many new features and optimizing especially in compressing header information via HPAC to lower the amount of data transported per each request.
With the HTTP/3 now a new way is established with a protocol not based on TCP/IP but on a protocol called QUIC which is built on top of UDP.
\end{flushleft}
\subsection{The HTTP/2 and HTTP/3 protocols}
\begin{flushleft}
The HTTP/2 protocol is. built on top of the TCP/IP. protocol. A. header values compression takes place here called HPACK. HPACK uses the Huffman algorithm to compress header values in an encode / decode process. Since TCP / IP is designed im the first priority to be reliable and to keep data consistent as well as not loosing data packages it is not optimal for transporting a high amount of data even also parallel in a short time. For that reason \abbrhighcol{HTTP/3} was developed based on the \abbrhighcol {QUIC protocol} \footnote{\abbrhighcol {QUIC protocol:} \abbrhighcol{Q}uick \abbrhighcol {UDP} \abbrhighcol{I}nternet \abbrhighcol{C}onnection}.
\abbrhighcol {TCP}\footnote{\abbrhighcol {TCP:} \abbrhighcol {T}ransmission \abbrhighcol {C}ontrol \abbrhighcol {P}rotocol} and \abbrhighcol {UDP} \footnote{\abbrhighcol{UDP: }\abbrhighcol{U}ser \abbrhighcol{D}atagram \abbrhighcol{P}rotocol} are two different ways of handling data transfer and requests in the internet.They handle data and requests and responses. in another way. UDP is connection less unordered and faster. TCP has the advantage that data loss is correctly detected and handled and that the data are checked for consistence. The QUIC protocol is designed to have a way of using UDP with the additional advantage that the consistence of data is save as far as possible.  
\end{flushleft}
\end{multicols}
\end{document}